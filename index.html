

<!doctype html>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three/examples/js/controls/PointerLockControls.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.9.0/nipplejs.min.js"></script>




<style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    :root {
    --scene-bg-color: #1a1a1a; /* Default color */
}

    #instructions {
        position: absolute;
        top: 55%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 24px;
        font-family: 'Arial', sans-serif;
        color: #ffffff;
        background: rgba(0, 0, 0, 0.0);
        padding: 20px;
        border-radius: 0px;
        text-align: center;
        cursor: pointer;
        white-space: nowrap;
        z-index: 9999;
    }



    .mobile-controls {
    position: fixed;
    bottom: 60px;
    right: 20px;
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 20px;
}

.mobile-controls-up {
    position: fixed;
    bottom: 110px;
    right: 50px;
}

.mobile-controls-down {
    position: fixed;
    bottom: 10px;
    right: 50px;
}

.mobile-controls button,
.mobile-controls-up button,
.mobile-controls-down button {
    width: 40px;
    height: 40px;
    font-size: 20px;
    border: none;
    background: #333;
    color: white;
    border-radius: 5px;
}



        /* Show only on screens smaller than X px (typical mobile width) */
@media (max-width: 1024px) {
    .mobile-controls, 
    .mobile-controls-up, 
    .mobile-controls-down {
        display: flex;
    }
}


    .black-box {
        background-color:  #ffffff;
        color: #222222;
        padding: 15px 15px;
        border-radius: 0px;
        display: inline-block;
    }

    .black-box2 {
        
        color: #ffffff;
        padding: 15px 15px;
        border-radius: 0px;
        display: inline-block;
    }

     .black-box3 {
        background-color: #131313;
        color: #ffffff;
        padding: 15px 15px;
        border-radius: 0px;
        display: inline-block;
    }



    /* Progress bar style */
    #progress-bar {
        position: absolute;
        top: 4%;
        left: 50%;
        transform: translateX(-50%);
        width: 70%;
        height: 2px;
        background-color: #555555;
        border-radius: 0px;
    }

    

    #progress-bar-inner {
        height: 100%;
        background-color: #ffffff;
        border-radius: 0px;
    }



    .progress-marker {
    position: absolute;
    bottom: -15px; /* Adjust position below the progress bar */
    transform: translateX(-50%);
    text-align: center;
    
}

.progress-lineHor {
    width: 100%;
    height: 4px;
    background-color: var(--scene-bg-color);
    position: absolute;   /* Allow for vertical positioning */
    transform: rotate(0deg); /* Rotate text 45 degrees clockwise */
    transform-origin: center center; /* Optional: Keeps the text centered while rotating */
}

.progress-lineCover {
    
    height: 55px;
    background-color: var(--scene-bg-color);
    position: absolute;
    top: 50px;            /* Adjust this value to lower the line */
    transform: rotate(0deg); /* Rotate text 45 degrees clockwise */
    transform-origin: center center; /* Optional: Keeps the text centered while rotating */
}

.progress-label2 {
    font-size: 13px;
    color: #222222;
    white-space: nowrap;
    position: relative;
    top: -75px;
    font-family: 'Arial', sans-serif;
    display: inline-block;  /* Ensure the element can be rotated */
    transform: rotate(0deg); /* Rotate text 45 degrees clockwise */
    transform-origin: center center; /* Optional: Keeps the text centered while rotating */
    font-weight: bold;
}

.progress-line2 {
    width: 4px;
    height: 56px;
    background-color: var(--scene-bg-color);
    margin: 0 auto;
    position: relative;   /* Allow for vertical positioning */
    top: -61px;            /* Adjust this value to lower the line */
}




.progress-label {
    font-size: 13px;
    color: #222222;
    white-space: nowrap;
    position: relative;
    top: -23px;
    font-family: 'Arial', sans-serif;
    display: inline-block;  /* Ensure the element can be rotated */
    transform: rotate(0deg); /* Rotate text 45 degrees clockwise */
    transform-origin: center center; /* Optional: Keeps the text centered while rotating */
    font-weight: bold;
}

.progress-line {
    width: 4px;
    height: 50px;
    background-color: var(--scene-bg-color);
    margin: 0 auto;
    position: relative;   /* Allow for vertical positioning */
    top: -15px;            /* Adjust this value to lower the line */
    transform: rotate(0deg); /* Rotate text 45 degrees clockwise */
    transform-origin: center center; /* Optional: Keeps the text centered while rotating */
}



.progress-line2b {
    width: 4px;
    height: 50px;
    background-color: #ffffff;
    margin: 0 auto;
    position: relative;   /* Allow for vertical positioning */
    top: 10px;            /* Adjust this value to lower the line */
}




.progress-label2b {
    font-size: 11px;
    color: #ffffff; /* White text */
    background-color: none; /* Yellow background */
    white-space: nowrap;
    position: relative;
    text-align: left;
    top: -70px;
    font-family: 'Arial', sans-serif;
    display: inline-block;  /* Ensure the element can be rotated */
    transform: rotate(-0deg); /* Rotate text 45 degrees clockwise */
    transform-origin: center center; /* Keeps the text centered while rotating */
    
    padding: 5px 8px; /* Adds space inside the box */
    border: 0px solid #ffffff; /* Optional: Adds a black border */
    border-radius: 0px; /* Optional: Rounds the corners slightly */
}

.progress-label2c {
    font-size: 11px;
    color: #ffffff; /* White text */
    background-color: none; /* Yellow background */
    white-space: nowrap;
    position: relative;
    text-align: left;
    top: -22px;
    font-family: 'Arial', sans-serif;
    display: inline-block;  /* Ensure the element can be rotated */
    transform: rotate(-0deg); /* Rotate text 45 degrees clockwise */
    transform-origin: center center; /* Keeps the text centered while rotating */
    
    padding: 5px 8px; /* Adds space inside the box */
    border: 0px solid #ffffff; /* Optional: Adds a black border */
    border-radius: 0px; /* Optional: Rounds the corners slightly */
}


.mobile-controls button, .mobile-controls-up button, .mobile-controls-down button, .progress-label2c, 
.progress-label2b, .progress-label, .progress-label2, .progress-line, .progress-line2, #instructions {
    user-select: none; /* Prevents text selection */
    -webkit-user-select: none; /* Safari */
    -moz-user-select: none; /* Firefox */
    -ms-user-select: none; /* Internet Explorer/Edge */
    touch-action: manipulation; /* Prevents long-press actions like "copy" */
}


@media screen and (orientation: portrait) {
    body::before {
        content: "Please rotate your device to landscape mode and move forward with the invisible joystick in the bottom-left corner";
        position: fixed;
        top: 40%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: white;
        color: #222222;
        padding: 40px;
        font-size: 40px;
        z-index: 9999;
        text-align: center;
    }

    body {
        overflow: hidden; /* Prevent scrolling in portrait mode */
    }

}

#joystick-container {
    position: fixed;
    bottom: 20px;
    left: 20px;
    width: 150px;
    height: 150px;
    z-index: 1100; /* Keep it above the canvas */
}





#fullscreenBtn {
    position: fixed;
    top: 20px;
    right: 20px;
    padding: 10px 15px;
    font-size: 16px;
    background: rgba(0, 0, 0, 0.7);
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    z-index: 1000;
  }

  #fullscreenBtn:hover {
    background: rgba(0, 0, 0, 0.9);
  }

</style>

<button id="fullscreenBtn">üî≤ Fullscreen</button>

<div id="joystick-container"></div>

<div class="mobile-controls">
    <button id="rotateLeft">‚óÄ</button>  <!-- Rotate Left -->
    <button id="rotateRight">‚ñ∂</button> <!-- Rotate Right -->
</div>

<div class="mobile-controls-up">
    <button id="moveUp">‚ñ≤</button>
</div>

<div class="mobile-controls-down">
    <button id="moveDown">‚ñº</button>
</div>




<div id="instructions">
    <span class="black-box2" style="font-size: 100px; color: #ffffff; font-family: Georgia, 'Times New Roman', Times, serif;">Gaza</span> <br/> <span class="black-box2" style="font-size: 50px; color: #ffffff; font-family: Georgia, 'Times New Roman', Times, serif;">they have names</span><br/><br/><br/><br/><br/><br/><br/><br/>

    <span class="black-box">Click to enter and press "W" to move forward</span><br /><br /><span class="black-box3"><strong>controls:</strong><br/>‚úõ Forward and sideward = WASD + mouse. <br/>‚Üï Up and down = QE</span>
</div>

<div id="progress-bar">

<!-- CHANGETHIS-->

<div id="progress-bar-inner">
    </div>

</div>

</div>

<script>

document.getElementById("fullscreenBtn").addEventListener("click", function () {
    const element = document.documentElement; // Make the whole page fullscreen
    if (!document.fullscreenElement) {
        element.requestFullscreen().then(() => {
            document.getElementById("fullscreenBtn").textContent = "X"; // Change to "X" in fullscreen mode
        }).catch(err => {
            console.error(`Fullscreen error: ${err.message}`);
        });
    } else {
        document.exitFullscreen();
    }
});

// Listen for fullscreen changes
document.addEventListener("fullscreenchange", () => {
    const btn = document.getElementById("fullscreenBtn");
    if (document.fullscreenElement) {
        btn.textContent = "X"; // Update when entering fullscreen
    } else {
        btn.textContent = "üî≤ Fullscreen"; // Reset when exiting fullscreen
    }
});



// create tilt with tiltAngle: 30 (backward) or -30 (forward)




let imageData = [
{ url: "https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", secondaryUrl:"https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", position: { x: 475, y: -135, z: -3700 }, size: { width: 945, height: 600 },  visibilityRange: 0 },
{ url: "https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", secondaryUrl:"https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", position: { x: 475, y: -135, z: -3000 }, size: { width: 945, height: 600 },  visibilityRange: 0 },
{ url: "https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", secondaryUrl:"https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", position: { x: 475, y: -135, z: -2300 }, size: { width: 945, height: 600 },  visibilityRange: 600 },
{ url: "https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", secondaryUrl:"https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", position: { x: 475, y: -135, z: -1600 }, size: { width: 945, height: 600 },  visibilityRange: 0 },   // OLIVE TREE
{ url: "https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", secondaryUrl:"https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", position: { x: 475, y: -135, z: -900 }, size: { width: 945, height: 600 },  visibilityRange: 0 },   
{ url: "https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", secondaryUrl:"https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", position: { x: 475, y: -135, z: -200 }, size: { width: 945, height: 600 },  visibilityRange: 0 },   
{ url: "https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", secondaryUrl:"https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", position: { x: 475, y: -135, z: 500 }, size: { width: 945, height: 600 }, visibilityRange: 500 },   
{ url: "https://lh3.googleusercontent.com/d/1Sw0YFEPmit3dYxNasXlcOswXgZOiO5sM", secondaryUrl:"https://lh3.googleusercontent.com/d/1Sw0YFEPmit3dYxNasXlcOswXgZOiO5sM", position: { x: 554, y: 115, z: 1200 }, size: { width: 500, height: 203.44 }, visibilityRange: 500 }, // LINE CHILDREN  
{ url: "https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", secondaryUrl:"https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", position: { x: 475, y: -135, z: 1500 }, size: { width: 945, height: 600 }, visibilityRange: 0 },   
{ url: "https://lh3.googleusercontent.com/d/1EZs29pWpEBagCadEiCRU2oC-P5guZqj0", secondaryUrl:"https://lh3.googleusercontent.com/d/1EZs29pWpEBagCadEiCRU2oC-P5guZqj0", position: { x: 303, y: 135, z: 2000 }, size: { width: 500, height: 203.44 }, visibilityRange: 500 }, // LINE ADULTS & ELDERLY
{ url: "https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", secondaryUrl:"https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", position: { x: 475, y: -135, z: 2500 }, size: { width: 945, height: 600 }, visibilityRange: 0 },   
{ url: "https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", secondaryUrl:"https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", position: { x: 475, y: -135, z: 3500 }, size: { width: 945, height: 600 }, visibilityRange: 0 },   // 1100 rooms so far
{ url: "https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", secondaryUrl:"https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", position: { x: 475, y: -135, z: 4500 }, size: { width: 945, height: 600 },  visibilityRange: 700 },  // JOURNALISTS 
{ url: "https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", secondaryUrl:"https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", position: { x: 475, y: -135, z: 5500 }, size: { width: 945, height: 600 }, visibilityRange: 0 }, // Atef   
{ url: "https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", secondaryUrl:"https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", position: { x: 475, y: -135, z: 6500 }, size: { width: 945, height: 600 }, visibilityRange: 0 },   
{ url: "https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", secondaryUrl:"https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", position: { x: 475, y: -135, z: 7500 }, size: { width: 945, height: 600 }, visibilityRange: 0 }, // Heba   
{ url: "https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", secondaryUrl:"https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", position: { x: 475, y: -135, z: 8500 }, size: { width: 945, height: 600 }, visibilityRange: 0 },   
{ url: "https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", secondaryUrl:"https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", position: { x: 475, y: -135, z: 9500 }, size: { width: 945, height: 600 }, visibilityRange: 0 }, 
{ url: "https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", secondaryUrl:"https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", position: { x: 475, y: -135, z: 10500 }, size: { width: 945, height: 600 }, visibilityRange: 0 }, // Mo
{ url: "https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", secondaryUrl:"https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", position: { x: 475, y: -135, z: 11500 }, size: { width: 945, height: 600 }, visibilityRange: 0 },
{ url: "https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", secondaryUrl:"https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", position: { x: 475, y: -135, z: 12500 }, size: { width: 945, height: 600 }, visibilityRange: 0 },
{ url: "https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", secondaryUrl:"https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", position: { x: 475, y: -135, z: 13500 }, size: { width: 945, height: 600 }, visibilityRange: 0 },
{ url: "https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", secondaryUrl:"https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", position: { x: 475, y: -135, z: 14500 }, size: { width: 945, height: 600 }, visibilityRange: 0 },
{ url: "https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", secondaryUrl:"https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", position: { x: 475, y: -135, z: 15500 }, size: { width: 945, height: 600 }, visibilityRange: 0 },
{ url: "https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", secondaryUrl:"https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", position: { x: 475, y: -135, z: 16500 }, size: { width: 945, height: 600 }, visibilityRange: 0 },
{ url: "https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", secondaryUrl:"https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", position: { x: 475, y: -135, z: 17500 }, size: { width: 945, height: 600 }, visibilityRange: 0 }, 
{ url: "https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", secondaryUrl:"https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", position: { x: 475, y: -135, z: 18500 }, size: { width: 945, height: 600 }, visibilityRange: 0 },// keep going
{ url: "https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", secondaryUrl:"https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", position: { x: 475, y: -135, z: 19500 }, size: { width: 945, height: 600 }, visibilityRange: 0 },
{ url: "https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", secondaryUrl:"https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", position: { x: 475, y: -135, z: 20500 }, size: { width: 945, height: 600 }, visibilityRange: 0 },
{ url: "https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", secondaryUrl:"https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", position: { x: 475, y: -135, z: 21500 }, size: { width: 945, height: 600 }, visibilityRange: 0 },
{ url: "https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", secondaryUrl:"https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", position: { x: 475, y: -135, z: 22500 }, size: { width: 945, height: 600 }, visibilityRange: 0 },
{ url: "https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", secondaryUrl:"https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", position: { x: 475, y: -135, z: 23500 }, size: { width: 945, height: 600 }, visibilityRange: 0 },
{ url: "https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", secondaryUrl:"https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", position: { x: 475, y: -135, z: 24500 }, size: { width: 945, height: 600 }, visibilityRange: 0 },
{ url: "https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", secondaryUrl:"https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", position: { x: 475, y: -135, z: 25500 }, size: { width: 945, height: 600 }, visibilityRange: 0 },
{ url: "https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", secondaryUrl:"https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", position: { x: 475, y: -135, z: 26500 }, size: { width: 945, height: 600 }, visibilityRange: 0 },
{ url: "https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", secondaryUrl:"https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", position: { x: 475, y: -135, z: 27500 }, size: { width: 945, height: 600 }, visibilityRange: 0 },
{ url: "https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", secondaryUrl:"https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", position: { x: 475, y: -135, z: 28500 }, size: { width: 945, height: 600 }, visibilityRange: 0 },
{ url: "https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", secondaryUrl:"https://lh3.googleusercontent.com/d/1RE4X7PKsCx37cu1rEajNcNcLhzTDbr17", position: { x: 475, y: -135, z: 29500 }, size: { width: 945, height: 600 }, visibilityRange: 0 },




{ url:"https://lh3.googleusercontent.com/d/1TUPNfh_mD1hQi0FqQrIaPC9kz1SKMG7i", secondaryUrl:"https://lh3.googleusercontent.com/d/1xQF0rT00OeEte4zj5gr3Gr6mkGFSbn8K", position: { x: 75, y: 300, z: 5500 }, size: { width: 300, height: 300 },  visibilityRange: 600 },

];



// Create a texture loader
let loader = new THREE.TextureLoader();

// Array to store image meshes and corresponding text elements
let imageMeshes = [];
let textElements2 = [];

// Iterate through each image data and create the images
imageData.forEach(image => {
    loader.load(image.url, function(primaryTexture) {
        loader.load(image.secondaryUrl || image.url, function(secondaryTexture) {
            const geometry = new THREE.PlaneGeometry(image.size.width, image.size.height);

            // Material for original image
            const primaryMaterial = new THREE.MeshBasicMaterial({
                map: primaryTexture,
                transparent: true,
                opacity: 1, // for primary
                side: THREE.DoubleSide,
                depthWrite: false
            });

            // Material for secondary/fade image
            const secondaryMaterial = new THREE.MeshBasicMaterial({
                map: secondaryTexture,
                transparent: true,
                opacity: 0, // Start invisible
                side: THREE.DoubleSide,
                depthWrite: false
            });

            // Two layered meshes
            const meshGroup = new THREE.Group();

            const primaryMesh = new THREE.Mesh(geometry, primaryMaterial);
            const secondaryMesh = new THREE.Mesh(geometry, secondaryMaterial);


            // Determine tilt in radians if present
            const tiltRadians = image.tiltAngle ? THREE.MathUtils.degToRad(image.tiltAngle) : 0;


            // Apply same transform
            [primaryMesh, secondaryMesh].forEach(mesh => {
            mesh.position.set(image.position.x, image.position.y, image.position.z);

            mesh.rotation.y = Math.PI;        // face the camera (or adjust as needed)
            mesh.rotation.x = tiltRadians;    // only tilt if specified
            });

            meshGroup.add(primaryMesh);
            meshGroup.add(secondaryMesh);

            scene.add(meshGroup);


            
            let textElement = document.createElement("div");

// Check if image.text is not undefined
if (image.text !== undefined) {
    textElement.innerHTML = image.text;


    Object.assign(textElement.style, {
        position: "absolute",
        bottom: "20px",    // Align with the bottom of the screen
        left: "50%",       // Align with the center of the screen
        fontSize: window.innerWidth > 1024 ? "25px" : "12px", // Adjust font size for desktop/mobile
        fontFamily: "'Helvetica Neue Light', 'Helvetica Neue', Helvetica, Arial, sans-serif",
        fontWeight: "300", // Light version
        color: "#1a1a1a",
        background: "rgba(255, 255, 255, 1)", // ‚úÖ white with 80% opacity
        padding: "20px",
        borderRadius: "0px",
        maxWidth: "75%",    // Max width of the box (50% of the screen width)
        width: "auto",      // Let the width adjust based on content (up to the max-width)
        display: "block",   // Set display to block if text is defined
        borderLeft: "0px solid #ffffff",
        transform: "translateX(-50%)"
    });

    // Append the text element to the body (or any other container you prefer)
    document.body.appendChild(textElement);
} else {
    console.log("Text is undefined");
}


            imageMeshes.push({
                group: meshGroup,
                primaryMesh,
                secondaryMesh,
                position: image.position,
                isFadingIn: false
            });


            textElements2.push({
    textElement,
    position: image.position,
    visibilityRange: image.visibilityRange || 150 // fallback if not defined (was 80)
});
        });
    });
});

// helper function
function handleImageVisibility(imageObj, textObj, shouldBeVisible) {
    textObj.textElement.style.display = shouldBeVisible ? "block" : "none";

    const fadeSpeed = 0.05;

    const primaryMaterial = imageObj.primaryMesh.material;
    const secondaryMaterial = imageObj.secondaryMesh.material;

    if (shouldBeVisible) {
        // Fade in secondary
        secondaryMaterial.opacity = Math.min(1, secondaryMaterial.opacity + fadeSpeed);

        // Fade out primary
        primaryMaterial.opacity = Math.max(0, primaryMaterial.opacity - fadeSpeed);
    } else {
        // Fade out secondary
        secondaryMaterial.opacity = Math.max(0, secondaryMaterial.opacity - fadeSpeed);

        // Fade in primary
        primaryMaterial.opacity = Math.min(1, primaryMaterial.opacity + fadeSpeed);
    }
}







// Function to update visibility based on x, y, and z distances and camera view direction
function updateImageTextVisibility() {
    let cameraPosition = controls.getObject().position;
    let cameraDirection = new THREE.Vector3();
    controls.getObject().getWorldDirection(cameraDirection);

    imageMeshes.forEach((imageObj, index) => {
        let distance = Math.sqrt(
            Math.pow(cameraPosition.x - imageObj.position.x, 2) +
            Math.pow(cameraPosition.y - imageObj.position.y, 2) +
            Math.pow(cameraPosition.z - imageObj.position.z, 2)
        );

        let textObj = textElements2[index];

        let vectorToImage = new THREE.Vector3(
            imageObj.position.x - cameraPosition.x,
            imageObj.position.y - cameraPosition.y,
            imageObj.position.z - cameraPosition.z
        ).normalize();

        let dotProduct = cameraDirection.dot(vectorToImage);

        // ‚úÖ Only do this once
        let shouldBeVisible = distance <= textObj.visibilityRange && dotProduct > 0;

        // Show/hide text
        textObj.textElement.style.display = shouldBeVisible ? "block" : "none";

        // Handle fade effect
        handleImageVisibility(imageObj, textObj, shouldBeVisible);
    });
}

// Function to update visibility on mobile (similar logic as above)
function updateImageTextVisibilityMobile() {
    let cameraPosition = camera.position;
    let cameraDirection = new THREE.Vector3();
    camera.getWorldDirection(cameraDirection);

    imageMeshes.forEach((imageObj, index) => {
        let distance = Math.sqrt(
            Math.pow(cameraPosition.x - imageObj.position.x, 2) +
            Math.pow(cameraPosition.y - imageObj.position.y, 2) +
            Math.pow(cameraPosition.z - imageObj.position.z, 2)
        );

        let textObj = textElements2[index];

        let vectorToImage = new THREE.Vector3(
            imageObj.position.x - cameraPosition.x,
            imageObj.position.y - cameraPosition.y,
            imageObj.position.z - cameraPosition.z
        ).normalize();

        let dotProduct = cameraDirection.dot(vectorToImage);

        let shouldBeVisible = distance <= textObj.visibilityRange && dotProduct > 0;

        textObj.textElement.style.display = shouldBeVisible ? "block" : "none";

        // ‚úÖ Add this to enable fade on mobile
        handleImageVisibility(imageObj, textObj, shouldBeVisible);
    });
}








// Initialize joystick
const joystick = nipplejs.create({
    zone: document.getElementById('joystick-container'),
    mode: 'dynamic',
    position: { left: '50%', top: '50%' },
    color: 'grey'
});

// Variables for movement
let moveX = 0, moveZ = 0;

// Listen for joystick movements
joystick.on('move', (evt, data) => {
    const angle = data.angle.degree; // Get movement angle
    const force = data.force; // Get movement force (speed)

    // Convert angle to movement direction
    moveX = Math.cos(angle * (Math.PI / 180)) * force;
    moveZ = Math.sin(angle * (Math.PI / 180)) * force;
});

// Stop movement when joystick is released
joystick.on('end', () => {
    moveX = 0;
    moveZ = 0;
});



let wordObjects = [
"Abdullah Mohammed Riyad Abdullah Al-Sayed Kul (0 years old)", 
];

let wordData = [

{ text: "Since October 7, 2023", positionZ: -4000, visibilityRange: 250, fontSize: 50 },    // 600 d
    { text: "more than 64 thousand people in Gaza<br>have been killed by the Israeli genocide", positionZ: -3400, visibilityRange: 250, fontSize: 80 }, // 600 d
    { text: "more than 18 thousand of those killed<br/>were children (one out of three)", positionZ: -2800, visibilityRange: 250, fontSize: 80 }, 
    { text: "Thousands more are missing<br/> and presumed dead", positionZ: -2000, visibilityRange: 250, fontSize: 80 }, 
    { text: "Many have not been buried<br/> in normal graves", positionZ: -1400, visibilityRange: 200, fontSize: 80 }, // 400 d
    { text: "If they would have been", positionZ: -800, visibilityRange: 200, fontSize: 80 },
    { text: "it would look like this", positionZ: -200, visibilityRange: 200, fontSize: 80 },


    { text: "the lighter-colored smaller stones represent the<br/>number of children killed and identified (18.430)", positionZ: 800, visibilityRange: 200, fontSize: 80 },
    { text: "the darker-colored larger stones show the number<br/> of adults and elderly killed and identified (45.938)", positionZ: 1600, visibilityRange: 200, fontSize: 80 },
    { text: "This will take you some time", positionZ: 2300, visibilityRange: 200, fontSize: 200 },
    { text: "(until you've reached the end<br/>of the progress bar above)", positionZ: 2800, visibilityRange: 200, fontSize: 80 },
    { text: "At this tree, you've only passed 1.100 stones<br/>(less than 2% of the total 64.468)", positionZ: 3300, visibilityRange: 200, fontSize: 80 },
    { text: "These are their names", positionZ: 3850, visibilityRange: 100, fontSize: 80 },


    { text: "Atef Dabour (15) was a member<br/>of Gaza‚Äôs Al-Hilal sports club.", positionZ: 5900, visibilityRange: 199, fontSize: 80 }, // 400 after tree, 400 d between lines
    { text: "Ever since he was a child<br/>he wanted to become a professional<br/>global football player", positionZ: 6300, visibilityRange: 199, fontSize: 80 },
    { text: "His ambition was crushed when<br/> an Israeli rocket took his life", positionZ: 6700, visibilityRange: 199, fontSize: 80 },
    { text: "and that of his father Muhammad Dabour,<br/>a pathology expert, and other members of his family", positionZ: 7100, visibilityRange: 199, fontSize: 80 },


    { text: "Heba Abu Nada (32)<br/>was a novelist and poet.", positionZ: 7900, visibilityRange: 199, fontSize: 80 }, // 400 d
    { text: "Her last poem, written the day before she was<br/>killed by Israeli bombs at Khan Younis, stated:", positionZ: 8300, visibilityRange: 199, fontSize: 80 },
    { text: "‚ùù The night in the city is dark<br/>except for the glow of the missiles", positionZ: 8700, visibilityRange: 199, fontSize: 80 },
    { text: "silent, except for the sound of the bombing", positionZ: 9100, visibilityRange: 199, fontSize: 80 },
    { text: "terrifying, except for the reassuring promise of prayer", positionZ: 9500, visibilityRange: 199, fontSize: 80 },
    { text: "black, except for the light of the martyrs", positionZ: 9900, visibilityRange: 199, fontSize: 80 },
    { text: "Good night ‚ùû", positionZ: 10300, visibilityRange: 199, fontSize: 80 },

    { text: "Mohammad Bhar (24)<br/>was a Palestinian man with<br/>Down syndrome and autism.", positionZ: 10900, visibilityRange: 199, fontSize: 80 },
{ text: "His house in Deir al-Balah was raided<br/>by Israeli soldiers with an army dog", positionZ: 11300, visibilityRange: 199, fontSize: 80 },
{ text: "His sister Sarah Bhar gave the following<br/>testimony to the Israeli ngo B'Tselem", positionZ: 11700, visibilityRange: 190, fontSize: 80 },
{ text: "‚ùù The dog pounced on Muhammad<br/>and bit him in the chest.", positionZ: 12100, visibilityRange: 199, fontSize: 80 },
{ text: "Muhammad was very frightened and<br/>started screaming at the dog:<br/>‚ÄúGet away! Get off me! Get away!‚Äù", positionZ: 12500, visibilityRange: 199, fontSize: 80 },
{ text: "The dog didn‚Äôt back off.", positionZ: 12900, visibilityRange: 199, fontSize: 80 },
{ text: "It grabbed Muhammad‚Äôs left arm below the shoulder", positionZ: 13300, visibilityRange: 199, fontSize: 80 },
{ text: "Muhammad was already bleeding heavily from his arm.", positionZ: 13700, visibilityRange: 199, fontSize: 80 },
{ text: "It was a terrible sight and<br/>we couldn‚Äôt do anything about it.", positionZ: 14100, visibilityRange: 199, fontSize: 80 },
{ text: "We tried to shout to the soldiers that we were civilians", positionZ: 14500, visibilityRange: 199, fontSize: 80 },
{ text: "that they should get the dog away<br/>from Muhammad, that Muhammad<br/>had a disability", positionZ: 14900, visibilityRange: 199, fontSize: 80 },
{ text: "Four of them pointed their guns at Muhammad.", positionZ: 15300, visibilityRange: 199, fontSize: 80 },
{ text: "Another group of soldiers pointed their guns<br/>at us and forced us to get down on our knees.", positionZ: 15700, visibilityRange: 199, fontSize: 80 },
{ text: "They ordered us to shut up.", positionZ: 16100, visibilityRange: 199, fontSize: 80 },
{ text: "The soldiers counted us and then ordered us to go downstairs.", positionZ: 16500, visibilityRange: 199, fontSize: 80 },
{ text: "My mother said, ‚ÄúLet me take Muhammad<br/>because he‚Äôs sick,‚Äù but they refused", positionZ: 16900, visibilityRange: 199, fontSize: 80 },
{ text: "That was the last time we saw Muhammad.", positionZ: 17300, visibilityRange: 199, fontSize: 80 },
{ text: "We left him bleeding on the couch.‚ùû", positionZ: 17700, visibilityRange: 199, fontSize: 80 },
     

{ text: "At this tree, you've passed 6.100 stones<br/>(almost 10% of the total 61.709)", positionZ: 19300, visibilityRange: 200, fontSize: 80 },


];

let wordData2 = [

// { text: "Masa Mohammed Youssef Nasr (0 years old)",   positionZ: 4250, visibilityRange: 95, fontSize: 80 },
// { text: "Ayat Abd Al-Aziz Omar Farwana (0 years old)",   positionZ: 4450, visibilityRange: 95, fontSize: 80 },
// { text: "Maalek Mohammed Shafeeq Abu-Al-Kas (0 years old)",   positionZ: 4650, visibilityRange: 95, fontSize: 80 },
// { text: "Sarah Abd Al-Rahman Mohammed Hamad (0 years old)",   positionZ: 4800, visibilityRange: 45, fontSize: 80 },
// { text: "Mohammed Saleh Mahmoud Al-Deiri (0 years old)",   positionZ: 4900, visibilityRange: 45, fontSize: 80 },
// { text: "Mecca Ahmed Eid Abu-Sherekh (0 years old)",   positionZ: 5000, visibilityRange: 45, fontSize: 80 },
// { text: "Iyad Abd Al-Rahman Jihad Muhaysen (0 years old)",   positionZ: 5100, visibilityRange: 45, fontSize: 80 },
// { text: "Adam Mohammed Sameer Abu-Ajwah (0 years old)",   positionZ: 5150, visibilityRange: 22, fontSize: 80 },
// { text: "Alayan Abd Al-Rahman Alayan Al-Ashqar (0 years old)",   positionZ: 5200, visibilityRange: 22, fontSize: 80 },
// { text: "Alma Moumen Mohammed Hamdan (0 years old)",   positionZ: 5250, visibilityRange: 22, fontSize: 80 },

]


let textElements = []; // To store the created elements

let totalWords = wordObjects.length; 
let startZ = 5275;
let endZ = 197365;
let spacing = (endZ - startZ) / totalWords; // Calculate spacing dynamically

// Create new words and add them to wordData
let newWords = wordObjects.map((text, index) => ({
    text,
    positionZ: startZ + index * spacing,  // Uses Z-position formula
    visibilityRange: 0,  // MAKE 2 to make all names visible
     type: 'name'
}));

wordData = wordData.map(d => ({ ...d, type: 'annotation' }));

wordData = [...newWords, ...wordData, ...wordData2];  // Merge existing and new words

console.log(wordData);



// Iterate through wordData to create and style elements
wordData.forEach(({ text, positionZ, visibilityRange, fontSize, color, type }) => {
    let textElement = document.createElement("div");
    textElement.innerHTML = text;

    let baseStyle = {
        position: "absolute",
        top: "10%",
        left: "50%",
        fontSize: window.innerWidth > 1024 ? "40px" : "20px",
        color: color || "#fffc9c",
        fontFamily: "Georgia, 'Times New Roman', Times, serif",
        textAlign: "center",
        display: "none",
        transform: "translate(-50%, -50%)",
        whiteSpace: "nowrap",
        overflow: "hidden",
        maxWidth: "90vw",
        wordBreak: "break-word",
    };

    // Only apply box styling if it's an annotation
    if (type === 'annotation') {
        Object.assign(baseStyle, {
            top: "80%",
            backgroundColor: "rgba(26, 26, 26, 1)",
            padding: "15px",
            borderRadius: "0px",
            margin: "10px 0",
            boxShadow: "0 4px 12px rgba(0, 0, 0, 0)",
        });
    }

    Object.assign(textElement.style, baseStyle);

    document.body.appendChild(textElement);
    textElements.push({ element: textElement, positionZ, visibilityRange });
});


// Update visibility based on camera position
function updateTextVisibility() {
    let cameraZ = controls.getObject().position.z;

    textElements.forEach(textObj => {
        let distance = Math.abs(cameraZ - textObj.positionZ);
        textObj.element.style.display = distance <= textObj.visibilityRange ? "block" : "none";
    });
}

function updateTextVisibilityMobile() {
    let cameraZ = camera.position.z; // Directly use the camera's position

    textElements.forEach(textObj => {
        let distance = Math.abs(cameraZ - textObj.positionZ);
        textObj.element.style.display = distance <= textObj.visibilityRange ? "block" : "none";
    });
}


function updateMobileControls() {
    const controls = document.querySelector('.mobile-controls');
    const controlsUp = document.querySelector('.mobile-controls-up');
    const controlsDown = document.querySelector('.mobile-controls-down');

    if (window.innerWidth < 1024 && camera.position.z > -400) {
        controls.style.display = 'flex'; 
        controlsUp.style.display = 'flex';  
        controlsDown.style.display = 'flex';  
    } else {
        controls.style.display = 'none';  
        controlsUp.style.display = 'none';  
        controlsDown.style.display = 'none';  
    }
}



    let scene, camera, renderer, controls;
    let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false, moveUp = false, moveDown = false, rotateLeft = false, rotateRight = false;
    let velocity = new THREE.Vector3();
    let direction = new THREE.Vector3();
    let isMobile = /Mobi|Android/i.test(navigator.userAgent);
    let totalDistance = 197440; // 50082 units along Z-axis
    let progressBarInner = document.getElementById("progress-bar-inner");
    





    init();

    

    animate();



    

    function init() {


        let instructionsVisible = true; // Initially, instructions are visible

        scene = new THREE.Scene();

         // Add fog to the scene
         scene.fog = new THREE.Fog(0x1a1a1a, 500, 800); // Lighter fog, with a more reasonable near/far range

          // Get the CSS variable value
    const cssColor = getComputedStyle(document.documentElement)
        .getPropertyValue('--scene-bg-color')
        .trim(); // Get CSS variable and trim spaces
        scene.background = new THREE.Color(cssColor);

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        if (!isMobile && 'PointerLockControls' in THREE) {
            controls = new THREE.PointerLockControls(camera, document.body);
            
  // Event listener for clicking on instructions
  document.getElementById('instructions').addEventListener('click', () => {
        controls.lock(); 
        instructionsVisible = false; // Hide instructions
    });

    // Event listeners for when controls are locked/unlocked
    controls.addEventListener('lock', () => {
        document.getElementById('instructions').style.display = 'none';
        instructionsVisible = false; // Hide instructions when controls are locked
    });
    
    controls.addEventListener('unlock', () => {
        document.getElementById('instructions').style.display = 'block';
        instructionsVisible = true; // Show instructions when controls are unlocked
    });

            controls.getObject().position.set(500, 213.5, 5000); // STARTPOSITION
            controls.getObject().rotation.y = Math.PI / 1; // Rotate 90 degrees to the right
            controls.getObject().rotation.x = -Math.PI / -20; // Tilt slightly downward

            scene.add(controls.getObject());

// Hide progress bar initially
document.getElementById("progress-bar").style.display = "none";


        } else {
            document.getElementById('instructions').style.display = 'none';

camera.position.set(500, 213.5, 5000); // STARTPOSITION
camera.rotation.y = Math.PI / 1;  // Rotate to face a specific direction
camera.rotation.x = Math.PI / 20; // Slight downward tilt
        }

        


        function createBlackLine(positionZ) {
            const lineGeometry = new THREE.PlaneGeometry(250, 10); // 2000 units wide, 2 units thick
            const lineMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
            const line = new THREE.Mesh(lineGeometry, lineMaterial);
            line.rotation.x = -Math.PI / 2; // Rotate to be parallel to the floor
            line.position.set(1150, -2.5, positionZ); // Centered horizontally, just below the floor
            scene.add(line);
        }

        function createBlackLine2(positionZ) {
            const lineGeometry = new THREE.PlaneGeometry(250, 10); // 2000 units wide, 2 units thick
            const lineMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
            const line = new THREE.Mesh(lineGeometry, lineMaterial);
            line.rotation.x = -Math.PI / 2; // Rotate to be parallel to the floor
            line.position.set(-170, -2.5, positionZ); // Centered horizontally, just below the floor
            scene.add(line);
        }

        function createVerticalLine(xPos, yPos, zPos, height) {
    const lineGeometry = new THREE.PlaneGeometry(13, height); // Width of 3 units, custom height
    const lineMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
    const line = new THREE.Mesh(lineGeometry, lineMaterial);

    // Rotate the line 90 degrees clockwise around the Y-axis (when viewed from above)
    line.rotation.y = -Math.PI; // Rotate 90 degrees clockwise around the Y-axis
    

    // Set the position to start at y = 0, and grow the line upwards
    line.position.set(xPos, yPos + height / 2, zPos); // Offset by half the height to start at y = 0

    scene.add(line);
}



// Load the textures
const textureLoader = new THREE.TextureLoader();

// Define textures for different height ranges
const textures = {
    small: textureLoader.load('https://lh3.googleusercontent.com/d/1ExF3IwkAyDWdQZ5x2SOSecdlHS_bZNqn'), // For height 20-25
    mediumSmall: textureLoader.load('https://lh3.googleusercontent.com/d/1Lu2VbLi26OwasGVvRP-d_pGLfw_guaJk'), // 25-30
    medium: textureLoader.load('https://lh3.googleusercontent.com/d/1gNnpMwp9ZMzo8H9Lb4NmFunmMhZSr3Da'), // 30-35
    tall: textureLoader.load('https://lh3.googleusercontent.com/d/1N6eCoFPRf2JI49jMMGH2e6qgxd2j5OZa'), // 35-45
    veryTall: textureLoader.load('https://lh3.googleusercontent.com/d/1vUMMGeUOj-8uy2zFIqU7fp88fowrChuN') // 45+
};

    

// Function to determine the texture based on height
function getTextureForHeight(height) {
    if (height >= 20 && height < 31) return textures.small;
    if (height >= 35 && height < 46) return textures.tall;
    return textures.medium; // Default texture
}



function createRoom(positionX, positionZ, positionY, width, height, depth) {
    const roomGeometry = new THREE.BoxGeometry(width, height, depth);
    const roomTexture = getTextureForHeight(height);

    // Use MeshStandardMaterial for lighting effects
    const material = new THREE.MeshStandardMaterial({ 
        map: roomTexture, 
        roughness: 0.7, // Adjust for shininess
        metalness: 0.1  // Low metal effect for a natural look
    });

    const materials = [material, material, material, material, material, material];
    const room = new THREE.Mesh(roomGeometry, materials);

    // Enable shadows
    room.castShadow = true;
    room.receiveShadow = true;

    room.position.set(positionX, positionY, positionZ);
    scene.add(room);
}

// ----- ADD LIGHTING -----

// Ambient Light (soft overall illumination)
const ambientLight = new THREE.AmbientLight(0xffffff, 0.4); // Color & intensity
scene.add(ambientLight);

// Directional Light (acts like the sun)
const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
directionalLight.position.set(300, 200, 400);
directionalLight.castShadow = false; // Enable shadows

scene.add(directionalLight);

// Optional: Point Light (adds extra highlights)
const pointLight = new THREE.PointLight(0xffffff, 0.8, 200);
pointLight.position.set(475, 20, -20);
pointLight.castShadow = false;
scene.add(pointLight);

// Enable shadow maps
renderer.shadowMap.enabled = false;
renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Soft shadows

directionalLight.shadow.camera.left = -500;
directionalLight.shadow.camera.right = 500;
directionalLight.shadow.camera.top = 500;
directionalLight.shadow.camera.bottom = -500;
directionalLight.shadow.camera.near = 1;
directionalLight.shadow.camera.far = 1000;



// Seeded random number generator
function seededRandom(seed) {
    let state = seed % 2147483647;
    if (state <= 0) state += 2147483646;
    return function () {
        state = (state * 16807) % 2147483647;
        return (state - 1) / 2147483646;
    };
}

// Set a fixed seed
const seed = 12345; // Change this for a different set of heights
const randomGen = seededRandom(seed);

// Define height ranges and their probabilities
const heightRanges = [
    { min: 20, max: 30, probability: 0.2863 },  // 50% of rooms
    { min: 35, max: 45, probability: 0.7137 }, // 40% of rooms
];

// Function to get a height based on defined probabilities
function getRandomHeight() {
    let r = randomGen(); // Get a random value between 0 and 1
    let cumulative = 0;
    
    for (let range of heightRanges) {
        cumulative += range.probability;
        if (r <= cumulative) {
            return Math.floor(randomGen() * (range.max - range.min + 1)) + range.min;
        }
    }
    return 20; // Default fallback (should never happen)
}


 // Create the rooms
let totalRooms = 0;

// Generate rooms with controlled height distribution
for (let y = 0; y < 2468; y++) { 
    for (let i = 0; i < 26; i++) { 
        let randomHeight = getRandomHeight();
        let positionY = randomHeight / 2; 
        createRoom(i * 40, y * 80, positionY, 20, randomHeight, 10); 
        totalRooms++;
    }



// Create the last row with only 9 rooms to reach exactly 61,709 [SLOWS THINGS DOWN]
// for (let i = 0; i < 9; i++) {
   // let randomHeight = getRandomHeight();
    // let positionY = randomHeight / 2;
    // createRoom(i * 40, 2468 * 80, positionY, 20, randomHeight, 10); 
    // totalRooms++;
// }

console.log("Total rooms created:", totalRooms);


    
// createRoom (500,710,100,400,200,5); // x,z,y and width, hight, depth
    


    // Add black lines after the specified number of rooms

    


    if (totalRooms >= 14557 && totalRooms < 14607) { 
        createBlackLine((y + 0.5) * 50);
    }

    if (totalRooms >= 17492 && totalRooms < 17542) { 
        createBlackLine2((y + 0.5) * 50);
    }

    if (totalRooms >= 43041 && totalRooms < 43091) { 
        createBlackLine((y + 0.5) * 50);
    }
    if (totalRooms >= 46583 && totalRooms < 46633) { 
        createBlackLine((y + 0.5) * 50);
    }

    if (totalRooms >= 47487 && totalRooms < 47537) { 
        createBlackLine2((y + 0.5) * 50);
    }

    if (totalRooms >= 48524 && totalRooms < 48574) { 
        createBlackLine((y + 0.5) * 50);
    }
}


// Create the floor geometry (a large plane)
const floorGeometry = new THREE.PlaneGeometry(20000, 20000);  // Width and Height of the floor

// Create the material with a specific color (e.g., light gray)
const floorMaterial = new THREE.MeshStandardMaterial({
    color: 0x444444,  // Color (light gray)
    roughness: 1,     // Optional: makes it less shiny
    metalness: 0,      // Optional: gives a non-metallic surface
    opacity: 0.0,     // Set opacity (0 = fully transparent, 1 = fully opaque)
    transparent: true,  // Enables transparency
    depthWrite: false // Prevents writing to the depth buffer
});


// Create a mesh with the geometry and material
const floor = new THREE.Mesh(floorGeometry, floorMaterial);

// Rotate the plane to lie flat on the X-Z plane (the default plane is along Y-Z)
floor.rotation.x = - Math.PI / 2;

// Position the floor at the appropriate Y-coordinate (e.g., Y = -10, below all objects)
floor.position.y = -5;

floor.receiveShadow = true;

// Add the floor to the scene
scene.add(floor);



// Create an HTML canvas to draw the gradient
const canvas = document.createElement('canvas');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
const ctx = canvas.getContext('2d');

// Create a linear gradient on the canvas (vertical gradient in this case)
const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
gradient.addColorStop(0, '#222222');  // Top color
gradient.addColorStop(1, '#111111');  // Bottom color

// Apply the gradient to the entire canvas
ctx.fillStyle = gradient;
ctx.fillRect(0, 0, canvas.width, canvas.height);

// Use the canvas as a texture for the background
const texture = new THREE.CanvasTexture(canvas);

// Set the texture as the scene background
scene.background = texture;



        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        document.addEventListener('keydown', (event) => {
            if (instructionsVisible) return; // Prevent movement if instructions are visible
            switch (event.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyD': moveRight = true; break;
                case 'KeyQ': moveUp = true; break;
                case 'KeyE': moveDown = true; break;
            }
        });

        document.addEventListener('keyup', (event) => {
            if (instructionsVisible) return; // Prevent movement if instructions are visible
            switch (event.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyD': moveRight = false; break;
                case 'KeyQ': moveUp = false; break;
                case 'KeyE': moveDown = false; break;
            }
        });
    }

    function animate() {
    requestAnimationFrame(animate);

    

    // For non-mobile (Pointer Lock Controls)
    if (controls && controls.isLocked) {
        const speed = 6;
        direction.z = Number(moveForward) - Number(moveBackward);
        direction.x = Number(moveRight) - Number(moveLeft);
        direction.y = Number(moveUp) - Number(moveDown);
        direction.normalize();
        velocity.z = direction.z * speed;
        velocity.x = direction.x * speed;
        velocity.y = direction.y * speed;

        controls.moveRight(velocity.x);
        controls.moveForward(velocity.z);
        controls.getObject().position.y += velocity.y;

        if (controls.getObject().position.y < 0) {
            controls.getObject().position.y = 0;}

        updateTextVisibility(); // Call visibility update function
        updateImageTextVisibility();

        

        // Update the progress bar based on Z position
        let currentZ = controls.getObject().position.z;
        let progress = Math.max(0, Math.min(1, (currentZ) / totalDistance));
        progressBarInner.style.width = (progress * 100) + '%';

        // Show progress bar only when Z is higher than 
        let progressBar = document.getElementById("progress-bar");
        if (currentZ > 2600) {
            progressBar.style.display = "block";  // Show progress bar
        } else {
            progressBar.style.display = "none";   // Hide progress bar
        }

        progressBarInner.style.width = (progress * 100) + '%';
    }

    // For mobile controls (without pointer lock)
    else {
    
        // Mobile movement (adjust for camera rotation)
const speed = 1;
const angle = camera.rotation.y; // Get current rotation angle

// Convert joystick input (moveX, moveZ) into a direction relative to camera orientation
const forwardX = Math.sin(angle);
const forwardZ = Math.cos(angle);
const rightX = Math.cos(angle);
const rightZ = -Math.sin(angle);

// Compute new movement direction
const deltaX = (-moveZ * forwardX) + (moveX * rightX);
const deltaZ = (-moveZ * forwardZ) + (moveX * rightZ);

camera.position.x += deltaX * speed;
camera.position.z += deltaZ * speed;



        camera.position.y += (Number(moveUp) - Number(moveDown)) * 3;

        // Ensure camera's Y position does not go below 0
    if (camera.position.y < 0) {
        camera.position.y = 0;
    }

    // Handle rotation
    if (rotateLeft) {
            camera.rotation.y += rotationSpeed;
        }
        if (rotateRight) {
            camera.rotation.y -= rotationSpeed;
        }


        updateTextVisibilityMobile(); // Call visibility update function
        updateImageTextVisibilityMobile();

        updateMobileControls(); // Check Z position

        

// Update the progress bar based on Z position
let currentZ = camera.position.z; // Use camera's position directly
let progress = Math.max(0, Math.min(1, (currentZ) / totalDistance));
        progressBarInner.style.width = (progress * 100) + '%';

        // Show progress bar only when Z is higher than -400
        let progressBar = document.getElementById("progress-bar");
        if (currentZ > 2600) {
            progressBar.style.display = "block";  // Show progress bar
        } else {
            progressBar.style.display = "none";   // Hide progress bar
        }

        progressBarInner.style.width = (progress * 100) + '%';

    

    }
    renderer.render(scene, camera);
}

// Mobile control button listeners
document.getElementById('moveUp').addEventListener('touchstart', () => moveUp = true);
document.getElementById('moveUp').addEventListener('touchend', () => moveUp = false);
document.getElementById('moveDown').addEventListener('touchstart', () => moveDown = true);
document.getElementById('moveDown').addEventListener('touchend', () => moveDown = false);

// Rotation speed
const rotationSpeed = 0.05;

// Mobile control button listeners for rotation
document.getElementById('rotateLeft').addEventListener('touchstart', () => rotateLeft = true);
document.getElementById('rotateLeft').addEventListener('touchend', () => rotateLeft = false);
document.getElementById('rotateRight').addEventListener('touchstart', () => rotateRight = true);
document.getElementById('rotateRight').addEventListener('touchend', () => rotateRight = false);


</script>
</!doctype>
